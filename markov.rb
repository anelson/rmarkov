class Markov
    NONWORD = "####"

    def initialize(order)
        @words = Hash.new
        @order = order
    end

    def learn(text) 
        word_list = tokenize_text(text);

        #Pad 'words' with the NONWORD char to get things rolling
        @order.times do
            word_list.insert(0, NONWORD)
        end

        #Append with NONWORD to terminate
        word_list << NONWORD

        word_list.each_with_index do |word, index| 
            learn_word(word_list[index - @order, @order + 1]) unless index < @order
        end
    end

    def generate
        #Start by picking a random state starting with NONWORD
        state = generate_initial_state()
        output = []

        #puts "Initial state: #{state.join(',')}"

        output << generate_word(state) while state.length > 0

        return output
    end

    # Saves the markov chains to a file
    def save(filename)
        state = {
            :order => @order,
            :words => @words
        }

        File.open(filename, 'w') do |file|
            file << @order << $/
            save_tuples @words, file
        end
    end

    # Creates and returns a new Markov object based on chains previously saved
    # with save
    def self.load(filename)
        File.open(filename, 'r') do |file|
            order = file.readline.chomp

            markov = Markov.new(order.to_i)

            markov.load_tuples(file)
    
            markov
        end
    end

    def get_states
        return @words
    end

    def set_states(states)
        @words = states
    end

    def save_tuples(words, file)
        words.each_pair do |key, value|
            save_tuples_prefix key, value, file
        end
    end

    def load_tuples(file)
        words = {}
        file.each_line do |line|
            tuple = line.chomp.split("\t")

            learn_word(tuple)
        end
    end

private

    def save_tuples_prefix(prefix, words, file)
        if words.kind_of?(Array)
            words.each do |word|
                file << prefix << "\t" << word << $/
            end
        else
            words.each_pair do |word, next_words|
                save_tuples_prefix(prefix + "\t" + word, next_words, file)
            end
        end
    end

    def generate_initial_state()
        # Build an array of @order elements, containing a randomly-selected starting sequence.
        state = []

        @order.times do 
            state << NONWORD
        end

        #puts "Seeded state with NONWORD values; priming state with word values"

        #Iterate generate_word @order times to clear the NONWORD values out of 'state' and prime it with
        #actual words
        @order.times do
            generate_word(state)
        end

        #puts "Seeded state: #{state.join(',')}"

        state
    end

    def generate_word(state)
        # State is an array of @order elements reflecting the last @order words generated by the
        # generator.  Shift the array so element 0 falls off and the rest of the elements shift
        # left by once place; the fallen-off element 0 is the next word generated.
        #
        # Append a new word to the end of the array based on the state transition probabilities
        # for the words in the array
        if state.length == @order
            next_word = generate_next_word(state)
    
            # Only add this to the state vector if it's a word value.
            # NONWORD indicates the end of the sequence
            if next_word != NONWORD
                state << next_word
            end
        end

        #puts "Generating word #{state[0]}; state: [#{state.join(',')}]"

        # 'pop' the left-most word off the state and return it
        return state.shift
    end

    def generate_next_word(state)
        # Given an @order-element state, generates another word consistent with the state transition
        # probabilities
        current_word = @words

        if state.length != @order  
            raise ArgumentError, "Word state has an incorrect number of elements, #{state.length} (should be #{@order})", caller
        end

        state.each do |word|
            if !current_word.include?(word)
                raise ArgumentError, "Word state [#{state.join(',')}] isn't a valid tuple"
            end
            current_word = current_word[word]
        end

        # current_word is now an array of possible next works.  Just pick one at random
        word = current_word[rand(current_word.length)]

        #puts "Generated word '#{word}' from state vector [#{state.join(',')}]"

        word
    end

    def tokenize_text(text)
        # Split text into an array of words on whitespace
        words = text.split(/\s+/)

        words
    end

    def learn_word(wordStates)
        #wordStates[wordStates.length-1] is the word to learn; the preceeding word(s) are used to build the Markov chain
        #puts "Learning #{wordStates.join(',')}"

        current_word = @words
        wordStates.each_with_index do |word, index|
            #puts "#{word}"

            if index < @order - 1
                current_word[word] ||= {}
                current_word = current_word[word]
            elsif index == @order - 1
                current_word[word] ||= []
                current_word = current_word[word]
            else
                current_word << word
            end
        end
    end
end
